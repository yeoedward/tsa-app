{
  "name": "pg-promise",
  "version": "0.7.1",
  "description": "PG + Promises/A+, with transactions.",
  "main": "index.js",
  "scripts": {
    "test": "make test"
  },
  "homepage": "https://github.com/vitaly-t/pg-promise",
  "repository": {
    "type": "git",
    "url": "https://github.com/vitaly-t/pg-promise.git"
  },
  "bugs": {
    "url": "https://github.com/vitaly-t/pg-promise/issues"
  },
  "keywords": [
    "pg",
    "promise",
    "transaction",
    "postgres",
    "promises-aplus"
  ],
  "author": {
    "name": "Vitaly Tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "license": "MIT",
  "engines": {
    "node": ">=0.10.x",
    "npm": ">=1.4.x"
  },
  "dependencies": {
    "pg": "4.x",
    "promise": "6.x"
  },
  "devDependencies": {
    "bluebird": "2.x",
    "jasmine-node": "1.x"
  },
  "readme": "pg-promise\r\n===========\r\n\r\nComplete access layer to [PG] via [Promises/A+].\r\n\r\n[![Build Status](https://travis-ci.org/vitaly-t/pg-promise.svg?branch=master)](https://travis-ci.org/vitaly-t/pg-promise)\r\n[![Dependency Status](https://david-dm.org/vitaly-t/pg-promise.svg)](https://david-dm.org/vitaly-t/pg-promise)\r\n\r\n---\r\n<a href=\"https://promisesaplus.com/\"><img align=\"right\" width=\"190\" height=\"190\" src=\"http://s8.postimg.org/k7dtue8lx/pg_promise.jpg\"></a>\r\n\r\n* Supporting [Promise], [Bluebird], [When], [Q], etc.\r\n* Transactions, functions, flexible query formatting;\r\n* Automatic database connections;\r\n* Strict query result filters.\r\n\r\n# Installing\r\n```\r\n$ npm install pg-promise\r\n```\r\n\r\n# Testing\r\n* Install project dependencies\r\n```\r\n$ npm install\r\n```\r\n* Run tests\r\n```\r\n$ make test\r\n```\r\nOn Windows you can also run tests with `test.bat`\r\n\r\n# Getting started\r\n\r\n### 1. Load the library\r\n```javascript\r\n// Loading the library:\r\nvar pgpLib = require('pg-promise');\r\n```\r\n### 2. Initialize the library\r\n```javascript\r\n// Initializing the library, with optional global settings:\r\nvar pgp = pgpLib(/*options*/);\r\n```\r\nYou can pass additional `options` parameter when initializing the library (see chapter [Initialization Options](#advanced) for details).\r\n\r\n### 3. Configure database connection\r\nUse one of the two ways to specify connection details:\r\n* Configuration Object:\r\n```javascript\r\nvar cn = {\r\n    host: 'localhost', // server name or IP address;\r\n    port: 5432,\r\n    database: 'my_db_name',\r\n    user: 'user_name',\r\n    password: 'user_password'\r\n};\r\n```\r\n* Connection String:\r\n```javascript\r\nvar cn = \"postgres://username:password@host:port/database\";\r\n```\r\nThis library doesn't use any of the connection's details, it simply passes them on to [PG] when opening a new connection.\r\nFor more details see pg connection parameters in [WiKi](https://github.com/brianc/node-postgres/wiki/pg#parameters) and\r\n[implementation](https://github.com/brianc/node-postgres/blob/master/lib/connection-parameters.js).\r\n\r\n### 4. Instantiate your database\r\n```javascript\r\nvar db = pgp(cn); // create a new database instance from the connection details\r\n```\r\nThere can be multiple database objects instantiated in the application from different connection details.\r\n\r\nYou are now ready to make queries against the database.\r\n\r\n# Usage\r\n\r\nThe library supports promise-chained queries on shared and detached connections.\r\nChoosing which one you want depends on the situation and personal preferences.\r\n\r\n### Detached Connections\r\n\r\nQueries in a detached promise chain maintain connection independently, they each acquire a connection from the pool,\r\nexecute the query and then release the connection.\r\n```javascript\r\ndb.one(\"select * from users where id=$1\", 123) // find the user from id;\r\n    .then(function(data){\r\n        // find 'login' records for the user found:\r\n        return db.query(\"select * from audit where event=$1 and userId=$2\",\r\n        [\"login\", data.id]);\r\n    })\r\n    .then(function(data){\r\n        // display found audit records;\r\n        console.log(data);\r\n    }, function(reason){\r\n        console.log(reason); // display reason why the call failed;\r\n    })\r\n```\r\nIn a situation where a single request is to be made against the database, a detached chain is the only one that makes sense.\r\nAnd even if you intend to execute multiple queries in a chain, keep in mind that even though each will use its own connection,\r\nsuch will be used from a connection pool, so effectively you end up with the same connection, without any performance penalty.\r\n\r\n### Shared Connections\r\n\r\nA promise chain with a shared connection always starts with ```connect()```, which allocates a connection that's shared with all the\r\nquery requests down the promise chain. The connection must be released when no longer needed.\r\n\r\n```javascript\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function(obj){\r\n        sco = obj; // save the connection object;\r\n        // find active users created before today:\r\n        return sco.query(\"select * from users where active=$1 and created < $2::date\", [true, new Date()]);\r\n    })\r\n    .then(function(data){\r\n        console.log(data); // display all the user details;\r\n    }, function(reason){\r\n        console.log(reason); // display reason why the call failed;\r\n    })\r\n    .done(function(){\r\n        if(sco){\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\nShared-connection chaining is for those who want absolute control over connection, either because they want to execute lots of queries in one go,\r\nor because they like squeezing every bit of performance out of their code. Other than, the author hasn't seen any real performance difference\r\nfrom the detached-connection chaining.\r\n\r\n### Transactions\r\n\r\nTransactions can be executed within both shared and detached promise chains in the same way, performing the following actions:\r\n\r\n1. Acquires a new connection (detached chains only);\r\n2. Executes `BEGIN` command;\r\n3. Invokes your callback function with the connection object;\r\n4. Executes `COMMIT`, if the callback resolves, or `ROLLBACK`, if the callback rejects;\r\n5. Releases the connection (detached chains only);\r\n6. Resolves with the callback result, if success; rejects with the reason, if failed.\r\n\r\n###### Example of a detached transaction:\r\n\r\n```javascript\r\nvar promise = require('promise'); // or any other supported promise library;\r\ndb.tx(function(ctx){\r\n\r\n    // creating a sequence of transaction queries:\r\n    var q1 = ctx.none(\"update users set active=$1 where id=$2\", [true, 123]);\r\n    var q2 = ctx.one(\"insert into audit(entity, id) values($1, $2) returning id\", ['users', 123]);\r\n\r\n    // returning a promise that determines a successful transaction:\r\n    return promise.all([q1, q2]); // all of the queries are to be resolved\r\n\r\n}).then(function(data){\r\n    console.log(data); // printing successful transaction output\r\n}, function(reason){\r\n    console.log(reason); // printing the reason why the transaction was rejected\r\n});\r\n```\r\nA detached transaction acquires a connection and exposes object `ctx` to let all containing queries execute on the same connection.\r\n\r\nAnd when executing a transaction within a shared connection chain, the only thing that changes is that parameter `ctx` becomes the\r\nsame as parameter `sco` from opening a shared connection, so either one can be used inside such a transaction interchangeably.\r\n\r\n###### Shared-connection transaction:\r\n```javascript\r\nvar promise = require('promise'); // or any other supported promise library;\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function(obj){\r\n        sco = obj;\r\n        return sco.oneOrNone(\"select * from users where active=$1 and id=$1\", [true, 123]);\r\n    })\r\n    .then(function(data){\r\n        return sco.tx(function(ctx){\r\n\r\n            // Since it is a transaction within a shared chain, it doesn't matter whether\r\n            // the two calls below use object `ctx` or `sco`, as they are exactly the same:\r\n            var q1 = ctx.none(\"update users set active=$1 where id=$2\", [false, data.id]);\r\n            var q2 = sco.one(\"insert into audit(entity, id) values($1, $2) returning id\", ['users', 123]);\r\n\r\n            // returning a promise that determines a successful transaction:\r\n            return promise.all([q1, q2]); // all of the queries are to be resolved;\r\n        });\r\n    }, function(reason){\r\n        console.log(reason); // printing the reason why the transaction was rejected;\r\n    })\r\n    .done(function(){\r\n        if(sco){\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\nIf you need to execute just one transaction, the detached transaction pattern is all you need.\r\nBut even if you need to combine it with other queries in then a detached chain, it will work just as fine.\r\nAs stated earlier, choosing a shared chain over a detached one is mostly a matter of special requirements and/or personal preference.\r\n\r\n###### Nested Transactions\r\n\r\nStarting with version 0.5.6, the library supports nested transactions.\r\n\r\nSimilar to the shared-connection transactions, nested transactions automatically share the connection between all levels.\r\nThis library sets no limitation as to the depth (nesting levels) of transactions supported.\r\n\r\nExample:\r\n\r\n```javascript\r\ndb.tx(function (ctx) {\r\n    var queries = [\r\n        ctx.none(\"drop table users;\"),\r\n        ctx.none(\"create table users(id serial not null, name text not null);\")\r\n    ];\r\n    for (var i = 0; i < 100; i++) {\r\n        queries.push(ctx.none(\"insert into users(name) values($1)\", \"name-\" + (i + 1)));\r\n    }\r\n    queries.push(\r\n        ctx.tx(function () {\r\n            return ctx.tx(function(){\r\n                return ctx.one(\"select count(*) from users\");\r\n            });\r\n        }));\r\n    return promise.all(queries);\r\n})\r\n.then(function (data) {\r\n    console.log(data); // printing transaction result;\r\n}, function (reason) {\r\n    console.log(reason); // printing why the transaction failed;\r\n})\r\n```\r\n\r\nThings to note from the example above:\r\n* Sub-transactions do not declare a context parameter in their callback. It is not because\r\nthey don't receive one, they all do, but they don't care in such situation because of the shared connection\r\nchain that will result in the same `ctx` object as for the main callback, so they just reuse it from the parent,\r\nfor simplicity;\r\n* A nested transaction cannot be disconnected from its container, i.e. it must get into the container's promise chain,\r\n or it will result in an attempt to execute against an unknown connection;\r\n* As expected, a failure on any level in a nested transaction will `ROLLBACK` and `reject` the entire chain.\r\n\r\n###### Transactions with SAVEPOINT\r\n\r\n`SAVEPOINT` in PostgreSQL caters for advanced transaction scenarios where partial `ROLLBACK` can be executed,\r\ndepending on the logic of the transaction.\r\n\r\nUnfortunately, this doesn't go along with the [Promises/A+] architecture that doesn't support partial `reject`.\r\n\r\nThe only work-around via promises is to strip a transaction into individual commands and execute them as a promise\r\nchain within a shared connection. The example below shows how this can be done.\r\n\r\n```javascript\r\nvar sco; // shared connection object;\r\nvar txErr; // transaction error;\r\nvar txData; // transaction data;\r\ndb.connect()\r\n    .then(function (obj) {\r\n        sco = obj; // save the connection object;\r\n        return promise.all([\r\n            sco.none('begin'),\r\n            sco.none('update users set name=$1 where id=$2', ['changed1', 1]),\r\n            sco.none('savepoint first'), // creating savepoint;\r\n            sco.none('update users set name=$1 where id=$2', ['changed2', 2]),\r\n            sco.none('rollback to first') // reverting to the savepoint;\r\n        ])\r\n            .then(function (data) {\r\n                txData = data; // save the transaction output data;\r\n                return sco.none('commit'); // persist changes;\r\n            }, function (reason) {\r\n                txErr = reason; // save the transaction failure reason;\r\n                return sco.none('rollback'); // revert changes;\r\n            });\r\n    })\r\n    .then(function () {\r\n        if (txErr) {\r\n            console.log('Rollback Reason: ' + txErr);\r\n        } else {\r\n            console.log(txData); // successful transaction output;\r\n        }\r\n    }, function (reason) {\r\n        console.log(reason); // connection issue;\r\n    })\r\n    .done(function () {\r\n        if (sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\n\r\nThe issue with stripping out a transaction like this and injecting `SAVEPOINT` - it gets much more\r\ncomplicated to control the result of individual commands within a transaction, you may need to check every\r\nresult and change the following commands accordingly. This is why it makes much more sense to do such\r\ntransactions inside SQL functions, and not on the client side.\r\n\r\n### Queries and Parameters\r\n\r\nEvery connection context of the library shares the same query protocol, starting with generic method `query`, that's defined as shown below:\r\n```javascript\r\nfunction query(query, values, qrm);\r\n```\r\n* `query` (required) - query string that supports standard variables formatting, using $1, $2, ...etc;\r\n* `values` (optional) - simple value or an array of simple values to replace the query variables;\r\n* `qrm` - (optional) Query Result Mask, as explained below...\r\n\r\nIn order to eliminate the chances of unexpected query results and make code more robust, each request supports parameter `qrm`\r\n(Query Result Mask), via type `queryResult`:\r\n```javascript\r\n///////////////////////////////////////////////////////\r\n// Query Result Mask flags;\r\n//\r\n// Any combination is supported, except for one + many.\r\nqueryResult = {\r\n    one: 1,     // single-row result is expected;\r\n    many: 2,    // multi-row result is expected;\r\n    none: 4,    // no rows expected;\r\n    any: 6      // (default) = many|none = any result.\r\n};\r\n```\r\n\r\nIn the following generic-query example we indicate that the call can return anything:\r\n```javascript\r\ndb.query(\"select * from users\");\r\n```\r\nwhich is equivalent to calling either one of the following:\r\n```javascript\r\ndb.query(\"select * from users\", undefined, queryResult.many | queryResult.none);\r\ndb.query(\"select * from users\", undefined, queryResult.any);\r\ndb.manyOrNone(\"select * from users\");\r\ndb.any(\"select * from users\");\r\n```\r\nThis usage pattern is facilitated through result-specific methods that can be used instead of the generic query:\r\n```javascript\r\ndb.many(query, values); // expects one or more rows\r\ndb.one(query, values); // expects single row\r\ndb.none(query, values); // expects no rows\r\ndb.any(query, values); // expects anything, same as `manyOrNone`\r\ndb.oneOrNone(query, values); // expects 1 or 0 rows\r\ndb.manyOrNone(query, values); // expects anything, same as `any`\r\n```\r\n\r\nEach query function resolves its **data** object according to the `qrm` that was used:\r\n* `none` - **data** is `null`. If the query returns any kind of data, it is rejected.\r\n* `one` - **data** is a single object. If the query returns no data or more than one row of data, it is rejected.\r\n* `many` - **data** is an array of objects. If the query returns no rows, it is rejected.\r\n* `one` | `none` - **data** is `null`, if no data was returned; or a single object, if there was one row of data returned.\r\nIf the query returns more than one row of data, the query is rejected.\r\n* `many` | `none` - **data** is an array of objects. When no rows are returned, **data** is an empty array.\r\n\r\nIf you try to specify `one` | `many` in the same query, such query will be rejected without executing it, telling you that such mask is not valid.\r\n\r\nIf `qrm` is not specified when calling generic `query` method, it is assumed to be `many` | `none`, i.e. any kind of data expected.\r\n\r\n> This is all about writing robust code, when the client specifies what kind of data it is ready to handle on the declarative level,\r\nleaving the burden of all extra checks to the library.\r\n\r\n### Functions and Procedures\r\nIn PostgreSQL stored procedures are just functions that usually do not return anything.\r\n\r\nSuppose we want to call function **findAudit** to find audit records by **user id** and maximum timestamp.\r\nWe can make such call as shown below:\r\n```javascript\r\ndb.func('findAudit', [123, new Date()])\r\n    .then(function(data){\r\n        console.log(data); // printing the data returned\r\n    }, function(reason){\r\n        console.log(reason); // printing the reason why the call was rejected\r\n    });\r\n```\r\nWe passed it **user id** = 123, plus current Date/Time as the timestamp. We assume that the function signature matches the parameters that we passed.\r\nAll values passed are serialized automatically to comply with PostgreSQL type formats.\r\n\r\nMethod `func` accepts optional third parameter - `qrm` (Query Result Mask), the same as method `query`.\r\n\r\nAnd when you are not expecting any return results, call `db.proc` instead. Both methods return a [Promise] object,\r\nbut `db.proc` doesn't take a `qrm` parameter, always assuming it is `one`|`none`.\r\n\r\nSummary for supporting procedures and functions:\r\n```javascript\r\ndb.func(query, values, qrm); // expects the result according to `qrm`\r\ndb.proc(query, values); // calls db.func(query, values, queryResult.one | queryResult.none)\r\n```\r\n\r\n### Conversion Helpers\r\n\r\nThe library provides several helper functions to convert basic javascript types into their proper PostgreSQL presentation that can be passed\r\ndirectly into queries or functions as parameters. All of such helper functions are located within namespace `pgp.as`, and each function\r\nreturns a formatted string when successful or throws an error when it fails.\r\n\r\n```javascript\r\npgp.as.bool(value); // returns proper PostgreSQL boolean presentation;\r\n\r\npgp.as.text(value); // returns proper PostgreSQL text presentation,\r\n                    // fixing single-quote symbols, wrapped in quotes;\r\n\r\npgp.as.date(value); // returns proper PostgreSQL date/time presentation,\r\n                    // wrapped in quotes;\r\n\r\npgp.as.csv(array);  // returns a CSV string with values formatted according\r\n                    // to their type, using the above methods;\r\n\r\npgp.as.format(query, values);\r\n            // Replaces variables in a query with their `values` as specified.\r\n            // `values` is either a simple value or an array of simple values.\r\n```\r\nAs these helpers are not associated with any database, they can be used from anywhere.\r\n\r\nThere are some cases where you might want to use a combination of these methods instead\r\nof the implicit parameter formatting through query methods. For example, if you want to\r\ngenerate a filter string to be used where applicable, you might use a code like this:\r\n\r\n```javascript\r\nfunction createFilter(filter){\r\n    var cnd = []; // conditions;\r\n    if(filter.start){\r\n        // add start date condition;\r\n        cnd.push(pgp.as.format(\"start >= $1::date\", filter.start));\r\n    }\r\n    if(filter.end){\r\n        // add end date condition;\r\n        cnd.push(pgp.as.format(\"end <= $1::date\", filter.end));\r\n    }\r\n    if(filter.active !== undefined){\r\n        // add active flag;\r\n        cnd.push(pgp.as.format(\"active = $1\", filter.active));\r\n    }\r\n    if(filter.name){\r\n        // add name-starts-with condition;\r\n        cnd.push(\"name like \" + pgp.as.text(filter.name + '%'));\r\n    }\r\n    return cnd.join(\" and \"); // returning the complete filter string;\r\n}\r\n```\r\n\r\n# Advanced\r\n\r\n### Initialization Options\r\n\r\nWhen initializing the library, you can pass object `options` with a set of properties\r\nfor global override of the library's behaviour:\r\n```javascript\r\nvar options = {\r\n    // pgFormatting - redirects query formatting to PG;\r\n    // promiseLib - overrides default promise library;\r\n    // connect - database 'connect' notification;\r\n    // disconnect - database 'disconnect' notification;\r\n    // query - query execution notification.\r\n};\r\nvar pgp = pgpLib(options);\r\n```\r\n\r\nBelow is the list of all the properties that are currently supported.\r\n\r\n---\r\n* `pgFormatting`\r\n\r\nBy default, **pg-promise** provides its own implementation of the query value formatting,\r\nusing the standard syntax of $1, $2, etc.\r\n\r\nAny query request accepts values for the variable within query string as the second parameter.\r\nIt accepts a single simple value for queries that use only one variable, as well as an array of simple values,\r\nfor queries with multiple variables in them.\r\n\r\n**pg-promise** implementation of query formatting supports only the basic javascript types: text, boolean, date, number and null.\r\n\r\nThose basic types are however sufficient to cover more complex scenarios. For example, binary data is exchanged with the\r\ndatabase using hex strings, as shown below.\r\n\r\n```javascript\r\nvar fs = require('fs');\r\n\r\n// read in image in hex format:\r\nfs.readFile('image.jpg', 'hex', function (err, imgData) {\r\n    var data = '\\\\x' + imgData; // indicate a hex string;\r\n    // inserting data into column 'img' of type 'bytea':\r\n    db.query('insert into images (img) values ($1)', data)\r\n        .then(function () {\r\n            // success;\r\n        }, function (reason) {\r\n            console.log(reason); // print why it failed;\r\n        });\r\n});\r\n```\r\n\r\nIf, instead, you want to use query formatting that's implemented by the [PG] library, set parameter `pgFormatting`\r\nto be `true` when initializing the library, and every query formatting will redirect to the [PG]'s implementation.\r\n\r\nAlthough this has huge implication to the library's functionality, it is not within the scope of this project to detail.\r\nFor any further reference you should use documentation of the [PG] library.\r\n\r\n**NOTE:** As of the current implementation, formatting parameters for calling functions (methods `func` and `proc`)\r\nis not affected by this override. If needed, use the generic `query` instead to invoke functions with redirected\r\nquery formatting.\r\n\r\n---\r\n* `promiseLib`\r\n\r\nSet this property to an alternative promise library compliant with the [Promises/A+] standard.\r\n\r\nBy default, **pg-promise** uses version of [Promises/A+] provided by [Promise]. If you want to override\r\nthis and force the library to use a different implementation of the standard, just set this parameter\r\nto the library's instance.\r\n\r\nExample of switching over to [Bluebird]:\r\n```javascript\r\nvar promise = require('bluebird');\r\nvar options = {\r\n    promiseLib: promise\r\n};\r\nvar pgp = pgpLib(options);\r\n```\r\n\r\n[Promises/A+] libraries that passed our compatibility test and are currently supported:\r\n\r\n* [Promise] - used by default\r\n* [Bluebird]\r\n* [When]\r\n* [Q]\r\n* [RSVP] - doesn't have `done()`, use `finally/catch` instead\r\n* [Lie] - doesn't have `done()`\r\n\r\n\r\nCompatibility with other [Promises/A+] libraries though possible, is an unknown.\r\n\r\n---\r\n* `connect`\r\n\r\nGlobal notification function of acquiring a new database connection.\r\n```javascript\r\nvar options = {\r\n    connect: function(client){\r\n        var cp = client.connectionParameters;\r\n        console.log(\"Connected to database '\" + cp.database + \"'\");\r\n    }\r\n}\r\n```\r\nIt can be used for diagnostics / connection monitoring within your application.\r\n\r\nThe function takes only one parameter - `client` object from the [PG] library that represents connection\r\nwith the database.\r\n\r\n---\r\n* `disconnect`\r\n\r\nGlobal notification function of releasing a database connection.\r\n```javascript\r\nvar options = {\r\n    disconnect: function(client){\r\n        var cp = client.connectionParameters;\r\n        console.log(\"Disconnecting from database '\" + cp.database + \"'\");\r\n    }\r\n}\r\n```\r\nIt can be used for diagnostics / connection monitoring within your application.\r\n\r\nThe function takes only one parameter - `client` object from the [PG] library that represents the connection\r\nthat's being released.\r\n\r\n---\r\n* `query`\r\n\r\nGlobal notification of a query that's being executed.\r\n```javascript\r\nvar options = {\r\n    query: function(client, query, params){\r\n        console.log(\"Executing query: \" + query);\r\n    }\r\n}\r\n```\r\nIt can be useful for diagnostics / logging within your application.\r\n\r\nNotification happens just before the query execution. And if the notification handler throws\r\nan error, the query execution will be intercepted and rejected with the error that's been\r\nthrown by the handler function.\r\n\r\nThe function receives the following parameters:\r\n* `client` - object from the [PG] library that represents the connection;\r\n* `query` - query that's being executed;\r\n* `params` - query parameters (only when `pgFormatting` is set to be `true`).\r\n\r\nPlease note, that should you set property `pgFormatting` to be `true`, the library no longer formats\r\nthe queries, and the `query` arrives pre-formatted. This is why extra parameter `params` was added.\r\n\r\n### Library de-initialization\r\nWhen exiting your application, make the following call:\r\n```javascript\r\npgp.end();\r\n```\r\nThis will release pg connection pool globally and make sure that the process terminates without any delay.\r\nIf you do not call it, your process may be waiting for 30 seconds (default) or so, waiting for the pg connection pool to expire.\r\n\r\n# History\r\n* Version 0.7.0 fixes the way `as.format` works (breaking change). Released: April 2, 2015.\r\n* Version 0.6.2 has good database test coverage. Released: March 28, 2015.\r\n* Version 0.5.6 introduces support for nested transaction. Released: March 22, 2015.\r\n* Version 0.5.3 - minor changes; March 14, 2015.\r\n* Version 0.5.1 included wider support for alternative promise libraries. Released: March 12, 2015.\r\n* Version 0.5.0 introduces many new features and fixes, such as properties **pgFormatting** and **promiseLib**. Released on March 11, 2015.\r\n* Version 0.4.9 represents a solid code base, backed up by comprehensive testing. Released on March 10, 2015.\r\n* Version 0.4.0 is a complete rewrite of most of the library, made first available on March 8, 2015.\r\n* Version 0.2.0 introduced on March 6th, 2015, supporting multiple databases.\r\n* A refined version 0.1.4 released on March 5th, 2015.\r\n* First solid Beta, 0.1.2 on March 4th, 2015.\r\n* It reached first Beta version 0.1.0 on March 4th, 2015.\r\n* The first draft v0.0.1 was published on March 3rd, 2015, and then rapidly incremented due to many initial changes that had to come in, mostly documentation.\r\n\r\n[PG]:https://github.com/brianc/node-postgres\r\n[Promises/A+]:https://promisesaplus.com/\r\n[Promise]:https://github.com/then/promise\r\n[Bluebird]:https://github.com/petkaantonov/bluebird\r\n[When]:https://github.com/cujojs/when\r\n[Q]:https://github.com/kriskowal/q\r\n[RSVP]:https://github.com/tildeio/rsvp.js\r\n[Lie]:https://github.com/calvinmetcalf/lie\r\n\r\n# License\r\n\r\nCopyright (c) 2015 Vitaly Tomilov (vitaly.tomilov@gmail.com)\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\nDEALINGS IN THE SOFTWARE.\r\n",
  "readmeFilename": "README.md",
  "_id": "pg-promise@0.7.1",
  "_from": "pg-promise@~0.7.1"
}
